<!DOCTYPE html>
<title>Beatsaber Space</title>
<script src="https://cdn.jsdelivr.net/combine/npm/three@0.96.0/build/three.min.js,npm/altspace@2.9.0/dist/altspace.min.js,npm/altspacevr-behaviors@1.1.5/js/altspaceutil.min.js"></script>
<script src="js/Lighting.js?derp3"></script>
<script>
	altspaceutil.getFullspaceApp().then(app => {

		elapsedTime = 0;
		numRings = 20;
		ringTimeOffset = 500;
		ringSpeed = 0.000025;
		ringSpinAmplitude = 20;
		ringSpacing = 100;

		//Create 2D Enclosure
		let nlayoutbrowser2D = new THREE.Mesh(new THREE.BoxBufferGeometry(5, 5, 5), Object.assign(new THREE.MeshBasicMaterial({ color: 0xccdd33, transparent: true, opacity: 0.2 }), { visible: false }));
		nlayoutbrowser2D.position.set(0, 2.5, 15);
		nlayoutbrowser2D.scale.set(5, 5, 5);
		nlayoutbrowser2D.rotation.set(0, THREE.Math.degToRad(180), 0);
		app.anchor.add(nlayoutbrowser2D);
		nlayoutbrowser2D.addBehaviors(
			new altspaceutil.behaviors.NativeComponent('n-layout-browser', { url: 'https://www.twitch.tv/wacomalt/' }),
			new altspaceutil.behaviors.NativeComponent('n-text', { text: 'n-layout-browser\n2D Enclosure', height: 6, fontSize: 4, verticalAlign: 'top' })
		);

		app.anchor.add(nlayoutbrowser2D);


		function createFloorLock() {
			// Create Floor Locks To Keep Player In Place
			let slotlock = new THREE.Group();
			altspaceutil.setCursorCollider(slotlock, true);
			slotlock.addBehavior(new altspaceutil.behaviors.NativeComponent('n-mesh-collider', { convex: false }));
			app.anchor.add(slotlock);

			/*let floorspot = new THREE.Mesh(new THREE.BoxBufferGeometry(0.1, 0.1, 0.1), new THREE.MeshBasicMaterial({ color: 'white' }));
			floorspot.position.set(0, -0.1, 0);
			app.anchor.add(floorspot);*/

			let box1 = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 10, 1), new THREE.MeshBasicMaterial({ color: 'red', visible: false }));
			box1.position.set(1, 0, 0);
			slotlock.add(box1);

			let box2 = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 10, 1), new THREE.MeshBasicMaterial({ color: 'blue', visible: false }));
			box2.position.set(0, 0, 1);
			slotlock.add(box2);

			let box3 = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 10, 1), new THREE.MeshBasicMaterial({ color: 'green', visible: false }));
			box3.position.set(-1, 0, 0);
			slotlock.add(box3);

			let box4 = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 10, 1), new THREE.MeshBasicMaterial({ color: 'yellow', visible: false }));
			box4.position.set(0, 0, -1);
			slotlock.add(box4);

			let button = new THREE.Mesh(new THREE.BoxBufferGeometry(0.4, 0.4, 0.4), new THREE.MeshBasicMaterial({ color: 'orange' }));
			button.position.set(0, 0, 0);
			altspaceutil.setCursorCollider(button, true);
			button.addEventListener('cursordown', event => {
				slotlock.visible = !slotlock.visible;
				slotlock.traverse(child => {
					child.visible = slotlock.visible;
				});
			});

			let button2 = new THREE.Mesh(new THREE.BoxBufferGeometry(0.4, 0.4, 0.4), new THREE.MeshBasicMaterial({ color: 'orange' }));
			button2.position.set(2, 1, 0);
			altspaceutil.setCursorCollider(button, true);
			button2.addEventListener('cursordown', event => {
				slotlock.visible = !slotlock.visible;
				slotlock.traverse(child => {
					child.visible = slotlock.visible;
				});
			});

			app.anchor.add(slotlock, button, button2);

			slotlock.visible = false;
			slotlock.traverse(child => {
				child.visible = slotlock.visible;
			});
		}
		function animate() {
			onAnimationFrame
		}
		createFloorLock();
		// Initialize vertex lighting
		//let lighting  = new Lighting();
		//let light = new THREE.PointLight( 0xff0000, 1, 100 )

		// Create Space Environment
		let assets = {
			'blackmetalmeshes': { url: 'assets/blackmetalmeshes.bom', scale: 0.6, position: { x: 0, y: 0, z: 0 } },
			'blueglowmeshes': { url: 'assets/blueglowmeshes.bom', scale: 0.6, position: { x: 0, y: 0, z: 0 } },
			'clearglassmeshes': { url: 'assets/clearglassmeshes.bom', scale: 0.6, position: { x: 0, y: 0, z: 0 } },
			'squareringblackmetal': { url: 'assets/squareringblackmetal.bom', scale: 0.6, position: { x: 0, y: 0, z: 0 } },
			'squareringred': { url: 'assets/squareringred.bom', scale: 0.6, position: { x: 0, y: 0, z: 0 } }
		};

		altspaceutil.loadAssets(assets).then(loadedAssets => {
			console.log(loadedAssets);	

			app.anchor.add(loadedAssets['blackmetalmeshes']);
			app.anchor.add(loadedAssets['blueglowmeshes']);
			app.anchor.add(loadedAssets['clearglassmeshes']);
			//app.anchor.add(light);

			//currently broken, Lighting calculate. Needs to run after geometry is added to scene. Not sure how.
			/*
			loadedAssets['blackmetalmeshes'].traverse( function(child) {
				if (child instanceof THREE.Mesh) {
					child.geometry = new THREE.Geometry().fromBufferGeometry(child.geometry)
					console.log(child);
					lighting.bakeVertexLighting(child, light)
					}
				});
			loadedAssets['blueglowmeshes'].traverse( function(child) {
				if (child instanceof THREE.Mesh) {
					child.geometry = new THREE.Geometry().fromBufferGeometry(child.geometry)
					console.log(child);
					lighting.bakeVertexLighting(child, light)
					}
				});
			loadedAssets['clearglassmeshes'].traverse( function(child) {
				if (child instanceof THREE.Mesh) {
					child.geometry = new THREE.Geometry().fromBufferGeometry(child.geometry)
					console.log(child);
					lighting.bakeVertexLighting(child, light)
					}
				});
			*/
			
			app.anchor.addBehavior(new class ElapsedTimeTracker {
			    awake(o) {
			        elapsedTime = 0;
			    }

			    update(deltaTime) {
			        elapsedTime += deltaTime;
			    }
			});

			class SpinBehavior {
			    constructor(timeOffset,speed,amplitude) {
			        this.timeOffset = timeOffset;
			        this.speed = speed;
			        this.amplitude = amplitude;
			    }

			    awake(o) {
			        this.object3d = o;
			    }

			    update(deltaTime) {
			        this.object3d.rotation.z = Math.sin((elapsedTime+this.timeOffset)/this.speed)*this.amplitude;
			    }
			}

			// Create First Ring
			let redRing = loadedAssets['squareringred'].clone();
			redRing.addBehavior(new SpinBehavior(ringTimeOffset, (1/ringSpeed), ringSpinAmplitude));
			redRing.position.set(0, 0, ringSpacing);
			app.anchor.add(redRing);

			let metalRing = loadedAssets['squareringblackmetal'].clone();
			metalRing.addBehavior(new SpinBehavior(ringTimeOffset, (1/ringSpeed), ringSpinAmplitude));
			metalRing.position.set(0, 0, ringSpacing);
			app.anchor.add(metalRing);

			//create rest of rings
			var i;
			for (i = 0; i < (numRings - 1); i++) {
				redRing = loadedAssets['squareringred'].clone();
				redRing.addBehavior(new SpinBehavior(ringTimeOffset * (i + 1), (1/ringSpeed), ringSpinAmplitude));
				redRing.position.set(0, 0, (ringSpacing * (i + 1)));
				app.anchor.add(redRing);

				metalRing = loadedAssets['squareringblackmetal'].clone();
				metalRing.addBehavior(new SpinBehavior(ringTimeOffset * (i + 1), (1/ringSpeed), ringSpinAmplitude));
				metalRing.position.set(0, 0, (ringSpacing * (i + 1)));
				app.anchor.add(metalRing);
			}

			//Skybox
			/*
			let skybox = new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 32, 32), new THREE.MeshBasicMaterial({ side: THREE.BackSide, map: altspaceutil.loadTexture('assets/Sky_EchoAdventureA.jpg') }));
			altspaceutil.setCursorCollider(skybox, false);
			app.anchor.add(skybox);
			*/
			});

	});
</script>